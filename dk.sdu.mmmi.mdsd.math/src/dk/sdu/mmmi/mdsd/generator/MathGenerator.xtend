/*
 * generated by Xtext 2.25.0
 */
package dk.sdu.mmmi.mdsd.generator

import dk.sdu.mmmi.mdsd.math.Div
import dk.sdu.mmmi.mdsd.math.LetBinding
import dk.sdu.mmmi.mdsd.math.MathExp
import dk.sdu.mmmi.mdsd.math.MathNumber
import dk.sdu.mmmi.mdsd.math.Minus
import dk.sdu.mmmi.mdsd.math.Mult
import dk.sdu.mmmi.mdsd.math.Plus
import dk.sdu.mmmi.mdsd.math.VarBinding
import dk.sdu.mmmi.mdsd.math.VariableUse
import java.util.Map
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import dk.sdu.mmmi.mdsd.math.External
import java.util.ArrayList
import java.util.List
import java.util.HashMap
import dk.sdu.mmmi.mdsd.math.ExternalUse
import dk.sdu.mmmi.mdsd.math.Expression
import dk.sdu.mmmi.mdsd.math.Parenthesis
import dk.sdu.mmmi.mdsd.math.Binding

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class MathGenerator extends AbstractGenerator {

	static Map<String, String> variables = new HashMap();
	static List<VarBinding> currentVarBindings = new ArrayList();
	val packageName = "math_expression";

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val mathExp = resource.allContents.filter(MathExp).next
		val generatedCode = genMathClass(mathExp)
		fsa.generateFile(packageName + "/" + mathExp.name + ".java", generatedCode)
	}

	def genMathClass(MathExp mathExp) {
		val clazz = mathExp.name
		val externals = mathExp.externals

		return '''
			package «packageName»;
			public class «clazz» {
				«FOR variable : mathExp.variables»
					public int «variable.name»;
				«ENDFOR»
				
				«IF externals.size > 0»
					private External external;
					
					public «clazz»(External external) {
						this.external = external;
					}
				«ENDIF»
				
				public void compute() {
					«FOR variable : getVariables(mathExp.variables)»
						«variable.name» = «variables.get(variable.name)»;
					«ENDFOR»
				}
			
				«IF externals.size > 0»
					public interface External {
						«FOR external : externals»public int «external.name»(«external.getInterfaceParams()»);«ENDFOR»
					}
				«ENDIF»
			}
		'''
	}

	def getInterfaceParams(External external) {
		var int nParam = 1
		return '''«FOR name : external.params SEPARATOR ', '»int n«nParam++»«ENDFOR»'''
	}

	def getVariables(List<VarBinding> varBindings) {
		currentVarBindings = new ArrayList(varBindings)
		val List<VarBinding> scopedVarBindings = new ArrayList();
		varBindings.forEach[varBinding|varBinding.compute(scopedVarBindings)]
		scopedVarBindings
	}

	def static void compute(VarBinding varBinding, List<VarBinding> varBindings) {
		if(!currentVarBindings.contains(varBinding)) return;
		variables.put(varBinding.name, varBinding.expression.computeExpression(variables, varBindings))
		varBindings.add(varBinding)
		currentVarBindings.remove(varBinding)
	}

	def static String computeExpression(Expression exp, Map<String, String> vars, List<VarBinding> varBindings) {
		println(exp)
		println(varBindings)
		switch exp {
			Plus:
				exp.left.computeExpression(vars, varBindings) + " + " + exp.right.computeExpression(vars, varBindings)
			Minus:
				exp.left.computeExpression(vars, varBindings) + " - " + exp.right.computeExpression(vars, varBindings)
			Mult:
				exp.left.computeExpression(vars, varBindings) + " * " + exp.right.computeExpression(vars, varBindings)
			Div:
				exp.left.computeExpression(vars, varBindings) + " / " + exp.right.computeExpression(vars, varBindings)
			Parenthesis:
				"(" + exp.exp.computeExpression(vars, varBindings) + ")"
			MathNumber:
				exp.value.toString()
			VariableUse: {
				val refName = exp.ref.name
				if (vars.containsKey(refName)) {
					return refName
				}
				for (VarBinding varBinding : new ArrayList(currentVarBindings).filter[name == refName]) {
					varBinding.compute(varBindings)
					if (variables.containsKey(refName)) {
						vars.put(refName, variables.get(refName))
						return refName

					}
				}
			}
			LetBinding: {
				exp.binding.computeExpression(vars, varBindings)
			}
			ExternalUse: {
				return '''this.external.«exp.ref.name»(«FOR paramExp : exp.exps SEPARATOR ', '»«paramExp.computeExpression(vars, varBindings)»«ENDFOR»)'''
			}
		}
	}
}
